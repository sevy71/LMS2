{% extends "base.html" %}

{% block title %}Picks Grid - Last Man Standing{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12 d-flex justify-content-between align-items-center">
            <h1 class="mb-4">Picks Grid</h1>
            <a href="{{ url_for('admin_dashboard') }}" class="btn btn-outline-secondary">
                <i class="fas fa-arrow-left"></i> Back to Dashboard
            </a>
        </div>
    </div>

    <div class="card">
        <div class="card-header d-flex flex-column gap-2">
            <div class="d-flex align-items-center gap-2 flex-wrap">
                <h5 class="card-title mb-0">All Player Picks</h5>
                <div class="d-flex align-items-center gap-2">
                    <label for="cycleSelect" class="form-label mb-0 small">Cycle:</label>
                    <select id="cycleSelect" class="form-select form-select-sm" style="width:auto;"></select>
                </div>
                <div class="btn-group ms-2" role="group" aria-label="View mode">
                    <button type="button" class="btn btn-sm btn-outline-secondary" id="viewPlayer">Player View</button>
                    <button type="button" class="btn btn-sm btn-outline-secondary" id="viewRound">Round View</button>
                </div>
                <button type="button" class="btn btn-sm btn-outline-primary d-sm-none" id="toggleMobileRounds" style="display:none;">
                    Show all rounds
                </button>
            </div>
            <div class="d-flex align-items-center gap-2 flex-wrap controls-scroll">
                <div class="input-group input-group-sm" style="max-width: 320px;">
                    <span class="input-group-text"><i class="fas fa-search"></i></span>
                    <input id="playerSearch" type="text" class="form-control" placeholder="Search players">
                </div>
                <div class="d-flex flex-wrap gap-1">
                    <button type="button" class="btn btn-outline-primary btn-sm" id="sortByName">üìù Sort by Name</button>
                    <button type="button" class="btn btn-outline-warning btn-sm" id="sortByStatus">üéØ Group by Status</button>
                    <button type="button" class="btn btn-outline-success btn-sm d-none d-sm-inline-block" id="sortByLatestRound">üé≤ Sort by Latest Round</button>
                    <button type="button" class="btn btn-outline-dark btn-sm" id="sortByProgress">üî¢ Active ‚Üí Teams Picked</button>
                    <button type="button" class="btn btn-outline-info btn-sm d-none d-sm-inline-block" id="adjustColumns">üìä Adjust Columns</button>
                    <div class="btn-group">
                        <button type="button" class="btn btn-outline-secondary btn-sm" id="exportGrid">‚¨áÔ∏è Export Grid CSV</button>
                        <button type="button" class="btn btn-outline-secondary btn-sm" id="exportGridExcel">‚¨áÔ∏è Export Grid Excel</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="card-body">
            <!-- Column width control -->
            <div class="row mb-3" id="columnControls" style="display: none;">
                <div class="col-md-6">
                    <label for="nameColWidth" class="form-label">Name Column Width:</label>
                    <input type="range" class="form-range" id="nameColWidth" min="100" max="300" value="150" onchange="updateColumnWidth('name', this.value)">
                    <small class="form-text text-muted">Current: <span id="nameWidthDisplay">150px</span></small>
                </div>
                <div class="col-md-6">
                    <label for="roundColWidth" class="form-label">Round Columns Width:</label>
                    <input type="range" class="form-range" id="roundColWidth" min="80" max="200" value="120" onchange="updateColumnWidth('round', this.value)">
                    <small class="form-text text-muted">Current: <span id="roundWidthDisplay">120px</span></small>
                </div>
            </div>

            <div class="d-flex justify-content-between align-items-center mb-2 flex-wrap gap-2" id="roundControls" style="display:none;">
                <div class="d-flex align-items-center gap-2">
                    <label for="roundSelect" class="form-label mb-0 small">Round:</label>
                    <select id="roundSelect" class="form-select form-select-sm" style="width:auto;"></select>
                    <button type="button" class="btn btn-sm btn-outline-secondary" id="showAllRoundsBtn" title="Show all rounds in grid">All Rounds</button>
                </div>
                <div class="d-flex align-items-center gap-3">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="activeOnly">
                        <label class="form-check-label" for="activeOnly">Active players only</label>
                    </div>
                </div>
            </div>

            <div id="grid-container" class="spreadsheet-container">
                <div class="p-3">
                    <div class="skeleton" style="height: 24px; margin-bottom: 8px;"></div>
                    <div class="skeleton" style="height: 24px; margin-bottom: 8px;"></div>
                    <div class="skeleton" style="height: 24px; width: 70%;"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
/* Spreadsheet Container */
.spreadsheet-container {
    height: 70vh;
    max-height: 800px;
    border: 2px solid #dee2e6;
    border-radius: 8px;
    overflow: hidden;
    position: relative;
    background: white;
}

/* Main Grid */
.spreadsheet-grid {
    display: grid;
    height: 100%;
    overflow: hidden;
}

/* Frozen Corner (top-left) */
.grid-corner {
    position: sticky;
    top: 0;
    left: 0;
    z-index: 30;
    background: #e9ecef;
    border-right: 2px solid #adb5bd;
    border-bottom: 2px solid #adb5bd;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 0.875rem;
}

/* Frozen Headers (top row) */
.grid-headers {
    position: sticky;
    top: 0;
    z-index: 20;
    background: #e9ecef;
    border-bottom: 2px solid #adb5bd;
    display: grid;
    grid-auto-columns: 120px;
    grid-auto-flow: column;
    overflow-x: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.grid-headers::-webkit-scrollbar {
    display: none;
}

.header-cell {
    padding: 12px 8px;
    border-right: 1px solid #adb5bd;
    background: #e9ecef;
    font-weight: bold;
    text-align: center;
    font-size: 0.875rem;
    position: relative;
    user-select: none;
}

.header-cell:hover {
    background: #d6d9dc;
}

.header-cell::after {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 4px;
    height: 100%;
    cursor: col-resize;
    background: transparent;
}

.header-cell:hover::after {
    background: rgba(0, 123, 255, 0.3);
}

.resize-handle {
    position: absolute;
    top: 0;
    right: -2px;
    width: 4px;
    height: 100%;
    cursor: col-resize;
    background: transparent;
    z-index: 10;
}

.resize-handle:hover,
.resize-handle.dragging {
    background: rgba(0, 123, 255, 0.5);
}

/* Frozen Name Column */
.grid-names {
    position: sticky;
    left: 0;
    z-index: 10;
    background: white;
    border-right: 2px solid #adb5bd;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.grid-names::-webkit-scrollbar {
    display: none;
}

.name-cell {
    padding: 10px 12px;
    border-bottom: 1px solid #dee2e6;
    background: white;
    font-weight: 600;
    font-size: 0.875rem;
    height: 45px;
    min-height: 45px;
    max-height: 45px;
    display: flex;
    align-items: center;
    position: relative;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* Data Grid */
.grid-data {
    overflow: auto;
    background: white;
}

.data-row {
    display: grid;
    grid-auto-columns: 120px;
    grid-auto-flow: column;
    border-bottom: 1px solid #dee2e6;
    height: 45px;
    min-height: 45px;
    max-height: 45px;
}

.data-cell {
    padding: 8px 6px;
    border-right: 1px solid #dee2e6;
    text-align: center;
    font-size: 0.875rem;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    background: white;
    height: 45px;
    min-height: 45px;
    max-height: 45px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* Alternating row colors */
.data-row:nth-child(even) .data-cell {
    background-color: #f8f9fa;
}

.name-cell:nth-child(even) {
    background-color: #f8f9fa;
}

/* Pick status styles */
.pick-winner {
    background-color: #d4edda !important;
    color: #155724;
    font-weight: bold;
}

.pick-loser {
    background-color: #f8d7da !important;
    color: #721c24;
    text-decoration: line-through;
}

.pick-pending {
    background-color: #fff3cd !important;
    color: #856404;
}

/* Player status row indicators */
.name-cell.player-eliminated {
    border-left: 4px solid #dc3545;
}

.name-cell.player-active {
    border-left: 4px solid #28a745;
}

.name-cell.player-winner {
    border-left: 4px solid #007bff;
}

/* Frozen Paid Column (second frozen column) */
.grid-corner-paid {
    left: 180px;
    border-left: 1px solid #adb5bd;
}

.grid-paid {
    position: sticky;
    left: 180px;
    z-index: 10;
    background: white;
    border-right: 2px solid #adb5bd;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.grid-paid::-webkit-scrollbar {
    display: none;
}

.paid-cell {
    padding: 4px 4px;
    border-bottom: 1px solid #dee2e6;
    border-left: 1px solid #dee2e6;
    background: white;
    font-size: 0.8rem;
    height: 45px;
    min-height: 45px;
    max-height: 45px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.paid-cell:nth-child(even) {
    background-color: #f8f9fa;
}

.paid-cell.group-header {
    background: #6c757d;
}

.paid-date-input {
    width: 100%;
    max-width: 95px;
    padding: 2px 4px;
    font-size: 0.75rem;
    border: 1px solid #ced4da;
    border-radius: 3px;
    background: white;
}

.paid-date-input:focus {
    border-color: #80bdff;
    outline: 0;
    box-shadow: 0 0 0 0.1rem rgba(0,123,255,.25);
}

.paid-date-input.saving {
    background-color: #fff3cd;
}

.paid-date-input.saved {
    background-color: #d4edda;
}

.paid-date-input.error {
    background-color: #f8d7da;
    border-color: #dc3545;
}

/* Status badges */
.status-badge {
    font-size: 0.7rem;
    padding: 3px 8px;
    border-radius: 12px;
    font-weight: bold;
}

.status-active {
    background-color: #28a745;
    color: white;
}

.status-eliminated {
    background-color: #dc3545;
    color: white;
}

.status-winner {
    background-color: #007bff;
    color: white;
}

/* Group headers for status sorting */
.group-header {
    grid-column: 1 / -1;
    padding: 8px 16px;
    background: #6c757d;
    color: white;
    font-weight: bold;
    text-align: center;
    font-size: 0.875rem;
}

/* Scrollbar styling */
.grid-data::-webkit-scrollbar {
    width: 12px;
    height: 12px;
}

.grid-data::-webkit-scrollbar-track {
    background: #f1f1f1;
}

.grid-data::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 6px;
}

.grid-data::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .spreadsheet-container {
        height: 60vh;
    }
    
    .grid-corner {
        width: 120px;
    }
    
    .header-cell,
    .data-cell {
        min-width: 100px;
    }
}

/* Controls overflow handling for small screens */
.controls-scroll { overflow-x: auto; }
.controls-scroll > * { white-space: nowrap; }

/* Round view uses vertical scroll inside container */
.spreadsheet-container.round-view { overflow: auto; }

/* Sticky table header inside round view scroll container */
.spreadsheet-container.round-view thead th {
    position: sticky;
    top: 0;
    z-index: 5;
}
</style>
{% endblock %}

{% block scripts %}
<script>
// Mapping of team names to display labels (mirrors backend team_abbrev)
function getTeamAbbreviation(teamName) {
    if (!teamName) return '';
    const normalized = teamName.trim().toLowerCase();
    const displayNames = {
        'arsenal': 'Arsenal',
        'arsenal fc': 'Arsenal',
        'aston villa': 'Villa',
        'aston villa fc': 'Villa',
        'afc bournemouth': 'Bournmouth',
        'bournemouth': 'Bournmouth',
        'bournemouth afc': 'Bournmouth',
        'brentford': 'Brentford',
        'brentford fc': 'Brentford',
        'brighton': 'Brighton',
        'brighton & hove albion': 'Brighton',
        'brighton and hove albion': 'Brighton',
        'brighton hove albion': 'Brighton',
        'burnley': 'Burnley',
        'burnley fc': 'Burnley',
        'chelsea': 'Chelsea',
        'chelsea fc': 'Chelsea',
        'crystal palace': 'Palace',
        'crystal palace fc': 'Palace',
        'palace': 'Palace',
        'everton': 'Everton',
        'everton fc': 'Everton',
        'fulham': 'Fulham',
        'fulham fc': 'Fulham',
        'leeds': 'Leeds',
        'leeds united': 'Leeds',
        'leeds united fc': 'Leeds',
        'liverpool': 'Liverpool',
        'liverpool fc': 'Liverpool',
        'manchester city': 'Man City',
        'manchester city fc': 'Man City',
        'man city': 'Man City',
        'manchester united': 'Man UTD',
        'manchester united fc': 'Man UTD',
        'man united': 'Man UTD',
        'newcastle': 'Newcastle',
        'newcastle united': 'Newcastle',
        'newcastle united fc': 'Newcastle',
        'nottingham forest': 'Forest',
        'nottm forest': 'Forest',
        'forest': 'Forest',
        'sunderland': 'Sunderland',
        'sunderland afc': 'Sunderland',
        'tottenham': 'Spurs',
        'tottenham hotspur': 'Spurs',
        'tottenham hotspur fc': 'Spurs',
        'spurs': 'Spurs',
        'west ham': 'West Ham',
        'west ham united': 'West Ham',
        'west ham united fc': 'West Ham',
        'wolverhampton wanderers': 'Wolves',
        'wolverhampton': 'Wolves',
        'wolves': 'Wolves'
    };
    return displayNames[normalized] || teamName.trim();
}

let gridData = null;
let currentSort = 'progress';
let currentView = 'player'; // 'player' | 'round'
let currentRoundKey = null; // Round key for Round View (e.g., "C2-R3")
let selectedCycle = 'current'; // Cycle filter value
let paymentCycle = null; // The cycle number used for payment dates (from API response)
let showAllMobileRounds = false; // player view compaction toggle
let playerViewRoundFilter = null; // When set, Player View shows only this round column
let eventListenersInitialized = false; // Prevent duplicate event bindings

document.addEventListener('DOMContentLoaded', function() {
    const gridContainer = document.getElementById('grid-container');

    // Default to Round view on small screens
    const isMobile = window.matchMedia && window.matchMedia('(max-width: 576px)').matches;
    if (isMobile) {
        currentView = 'round';
    }

    // Load data
    loadGridData('current');

    function loadGridData(cycle) {
        console.log('[Picks Grid] Loading data for cycle:', cycle);
        fetch(`/api/picks-grid-data?cycle=${cycle}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    gridData = data;
                    selectedCycle = cycle;
                    paymentCycle = data.payment_cycle || data.current_cycle || 1;

                    // Initialize cycle selector
                    initCycleSelector(data);

                    // Initialize round selector for Round View
                    initRoundSelector(data);

                    renderByView();

                    // Only set up event listeners once
                    if (!eventListenersInitialized) {
                        setupEventListeners();
                        eventListenersInitialized = true;
                    }
                } else {
                    gridContainer.innerHTML = `<div class="alert alert-danger">Error loading data: ${data.error}</div>`;
                }
            })
            .catch(error => {
                console.error('Error fetching picks grid data:', error);
                gridContainer.innerHTML = '<div class="alert alert-danger">Could not fetch data from the server.</div>';
            });
    }

    function initCycleSelector(data) {
        const cycleSelect = document.getElementById('cycleSelect');
        if (!cycleSelect) return;

        const cycles = data.available_cycles || [];
        const currentCycle = data.current_cycle || 1;

        let options = cycles.map(c => {
            const isCurrent = c === currentCycle;
            const label = `Cycle ${c}${isCurrent ? ' (Current)' : ''}`;
            const selected = (selectedCycle === 'current' && isCurrent) || selectedCycle === String(c) ? 'selected' : '';
            return `<option value="${c}" ${selected}>${label}</option>`;
        }).join('');

        cycleSelect.innerHTML = options;

        // Set initial value
        if (selectedCycle === 'current') {
            cycleSelect.value = String(currentCycle);
        }
    }

    function initRoundSelector(data) {
        const rounds = data.rounds || [];
        const roundSelect = document.getElementById('roundSelect');
        if (!roundSelect) return;

        if (rounds.length === 0) {
            roundSelect.innerHTML = '<option value="">No rounds</option>';
            currentRoundKey = null;
            return;
        }

        roundSelect.innerHTML = rounds.map(r => `<option value="${r.round_key}">${r.label}</option>`).join('');

        // Default to latest round
        const latestRound = rounds[rounds.length - 1];
        currentRoundKey = latestRound.round_key;
        roundSelect.value = currentRoundKey;
    }

    function onCycleChange(cycle) {
        console.log('[Picks Grid] Cycle changed to:', cycle);
        playerViewRoundFilter = null; // Reset single-round filter when cycle changes

        fetch(`/api/picks-grid-data?cycle=${cycle}`)
            .then(response => response.json())
            .then(newData => {
                if (newData.success) {
                    gridData = newData;
                    selectedCycle = cycle;
                    paymentCycle = newData.payment_cycle || newData.current_cycle || 1;

                    // Re-init round selector with new rounds for this cycle
                    initRoundSelector(newData);

                    renderByView();
                } else {
                    console.error('[Picks Grid] Failed to load cycle data:', newData.error);
                }
            })
            .catch(err => console.error('[Picks Grid] Error loading cycle:', err));
    }

    function sortPlayersForProgress(players) {
        // Active first, then by teams picked (descending), then name
        const statusOrder = { 'active': 1, 'winner': 2, 'eliminated': 3 };
        return [...players].sort((a, b) => {
            const aStatus = statusOrder[a.status] || 99;
            const bStatus = statusOrder[b.status] || 99;
            if (aStatus !== bStatus) return aStatus - bStatus;
            const aPicks = Object.values(a.picks || {}).filter(v => v !== null).length;
            const bPicks = Object.values(b.picks || {}).filter(v => v !== null).length;
            if (aPicks !== bPicks) return bPicks - aPicks; // more teams picked first
            return a.name.localeCompare(b.name);
        });
    }

    function applySearchFilter(players) {
        const q = (document.getElementById('playerSearch')?.value || '').trim().toLowerCase();
        if (!q) return players;
        return players.filter(p => p.name.toLowerCase().includes(q));
    }

    function renderByView() {
        if (!gridData) return;

        const rounds = gridData.rounds || [];
        if (rounds.length === 0) {
            gridContainer.innerHTML = '<div class="alert alert-info">No rounds found for this cycle.</div>';
            document.getElementById('roundControls').style.display = 'none';
            return;
        }

        if (currentView === 'round') {
            document.getElementById('columnControls').style.display = 'none';
            document.getElementById('roundControls').style.display = 'flex';
            // Allow vertical scrolling in round view
            const container = document.getElementById('grid-container');
            if (container) container.classList.add('round-view');
            renderRoundView(gridData);
            setActiveViewButton('viewRound');
            // hide mobile rounds toggle in round view
            const tgl = document.getElementById('toggleMobileRounds');
            if (tgl) tgl.style.display = 'none';
        } else {
            // Player View: show round controls so user can filter to a single round
            document.getElementById('roundControls').style.display = 'flex';
            const container = document.getElementById('grid-container');
            if (container) container.classList.remove('round-view');
            renderGrid(gridData, currentSort);
            setActiveViewButton('viewPlayer');
            // show mobile rounds toggle only on mobile
            const tgl = document.getElementById('toggleMobileRounds');
            if (tgl) tgl.style.display = isMobile ? 'inline-block' : 'none';
        }
    }

    function setActiveViewButton(activeId) {
        ['viewPlayer','viewRound'].forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;
            if (id === activeId) {
                el.classList.remove('btn-outline-secondary');
                el.classList.add('btn-secondary');
                el.setAttribute('aria-pressed', 'true');
            } else {
                el.classList.remove('btn-secondary');
                el.classList.add('btn-outline-secondary');
                el.setAttribute('aria-pressed', 'false');
            }
        });
    }

    function renderGrid(data, sortBy = 'name') {
        const rounds = data.rounds;
        let players = [...data.players]; // Create a copy

        if (players.length === 0) {
            gridContainer.innerHTML = '<p class="text-muted">No players found.</p>';
            return;
        }

        // Optional: filter active-only if toggle is on (applies to both views if set)
        const activeOnlyToggle = document.getElementById('activeOnly');
        if (activeOnlyToggle && activeOnlyToggle.checked) {
            players = players.filter(p => String(p.status || '').toLowerCase().trim() === 'active');
        }

        // Sort players
        if (sortBy === 'progress') {
            players = sortPlayersForProgress(players);
        } else if (sortBy === 'name') {
            players.sort((a, b) => a.name.localeCompare(b.name));
        } else if (sortBy === 'status') {
            // Group by status: active first, then eliminated, then winner
            players.sort((a, b) => {
                const statusOrder = { 'active': 1, 'eliminated': 2, 'winner': 3 };
                const aOrder = statusOrder[a.status] || 4;
                const bOrder = statusOrder[b.status] || 4;
                if (aOrder !== bOrder) return aOrder - bOrder;
                return a.name.localeCompare(b.name); // Secondary sort by name
            });
        } else if (sortBy === 'latestRound') {
            // Sort by latest round pick in ascending order
            const latestRound = rounds.length > 0 ? rounds[rounds.length - 1].round_key : null;
            if (latestRound) {
                players.sort((a, b) => {
                    const aLatestPick = a.picks[latestRound];
                    const bLatestPick = b.picks[latestRound];

                    // Players without picks go to the end
                    if (!aLatestPick && !bLatestPick) return a.name.localeCompare(b.name);
                    if (!aLatestPick) return 1;
                    if (!bLatestPick) return -1;

                    // Sort by team name in ascending order
                    const teamCompare = aLatestPick.team.localeCompare(bLatestPick.team);
                    if (teamCompare !== 0) return teamCompare;

                    // Secondary sort by name if same team
                    return a.name.localeCompare(b.name);
                });
            }
        }

        // Determine which round columns to render
        // Player View: if a round is selected, show only that round column
        // Otherwise, show all rounds (or compact on mobile)
        const compactMobile = isMobile && !showAllMobileRounds;
        let roundsToRender;
        if (playerViewRoundFilter) {
            // Filter to just the selected round
            roundsToRender = rounds.filter(r => r.round_key === playerViewRoundFilter);
        } else {
            roundsToRender = compactMobile ? rounds.slice(-2) : rounds;
        }

        // Create spreadsheet grid structure
        let gridHtml = '<div class="spreadsheet-grid" style="grid-template-columns: 180px 100px 1fr;">';

        // Top-left corner (spans both frozen columns)
        gridHtml += '<div class="grid-corner">Player</div>';
        gridHtml += '<div class="grid-corner grid-corner-paid">Paid (date)</div>';

        // Headers
        gridHtml += '<div class="grid-headers">';
        roundsToRender.forEach((round, index) => {
            gridHtml += `<div class="header-cell" data-round="${round.round_key}" data-col-index="${index}">
                ${round.label}
                <div class="resize-handle" data-col-index="${index}"></div>
            </div>`;
        });
        if (!compactMobile) {
            gridHtml += `<div class="header-cell" data-col-index="${roundsToRender.length}">
                Status
                <div class="resize-handle" data-col-index="${roundsToRender.length}"></div>
            </div>`;
        }
        gridHtml += '</div>';

        // Name column
        gridHtml += '<div class="grid-names">';
        let currentGroup = '';
        players.forEach((player, index) => {
            // Add group separator for status sorting
            if (sortBy === 'status' && currentGroup !== player.status) {
                currentGroup = player.status;
                const groupName = player.status.charAt(0).toUpperCase() + player.status.slice(1);
                const badgeClass = `status-${player.status}`;
                gridHtml += `<div class="name-cell group-header">
                    <span class="status-badge ${badgeClass}">${groupName} Players</span>
                </div>`;
            }

            const statusClass = `player-${player.status}`;
            gridHtml += `<div class="name-cell ${statusClass}">${player.name}</div>`;
        });
        gridHtml += '</div>';

        // Paid (date) column - frozen next to name
        gridHtml += '<div class="grid-paid">';
        currentGroup = '';
        players.forEach((player, index) => {
            // Add group separator for status sorting (blank cell for alignment)
            if (sortBy === 'status' && currentGroup !== player.status) {
                currentGroup = player.status;
                gridHtml += '<div class="paid-cell group-header"></div>';
            }

            const paidValue = player.cycle_paid_at || '';
            gridHtml += `<div class="paid-cell">
                <input type="date" class="paid-date-input" data-player-id="${player.id}" value="${paidValue}">
            </div>`;
        });
        gridHtml += '</div>';

        // Data grid
        gridHtml += '<div class="grid-data" id="dataGrid">';
        currentGroup = '';
        players.forEach((player, index) => {
            // Add group separator for status sorting
            if (sortBy === 'status' && currentGroup !== player.status) {
                currentGroup = player.status;
                gridHtml += '<div class="data-row"><div class="group-header"></div></div>';
            }

            gridHtml += '<div class="data-row">';

            // Round columns
            roundsToRender.forEach(round => {
                const pickData = player.picks[round.round_key];
                const pickInfo = getPickInfo(pickData, round.round_key);
                gridHtml += `<div class="data-cell ${pickInfo.class}" title="${pickInfo.tooltip}">${pickInfo.display}</div>`;
            });

            // Status column (hidden in compact mobile)
            if (!compactMobile) {
                const statusBadge = `<span class="status-badge status-${player.status}">${player.status.toUpperCase()}</span>`;
                gridHtml += `<div class="data-cell">${statusBadge}</div>`;
            }

            gridHtml += '</div>';
        });
        gridHtml += '</div>';
        
        gridHtml += '</div>';
        gridContainer.innerHTML = gridHtml;
        
        // Sync scrolling between headers and data
        syncScrolling();

        // Setup column resizing
        if (!compactMobile) {
            setupColumnResizing();
        }

        // Setup payment date change handlers
        setupPaymentDateHandlers();
    }

    function setupPaymentDateHandlers() {
        document.querySelectorAll('.paid-date-input').forEach(input => {
            input.addEventListener('change', function() {
                const playerId = this.dataset.playerId;
                const dateValue = this.value || null;
                const inputEl = this;
                const cycleNum = paymentCycle || 1;

                // Visual feedback: saving
                inputEl.classList.remove('saved', 'error');
                inputEl.classList.add('saving');

                // POST to per-cycle endpoint
                fetch(`/api/admin/cycles/${cycleNum}/players/${playerId}/paid-date`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ paid_at: dateValue })
                })
                .then(response => response.json())
                .then(data => {
                    inputEl.classList.remove('saving');
                    if (data.success) {
                        inputEl.classList.add('saved');
                        // Clear saved indicator after 2 seconds
                        setTimeout(() => inputEl.classList.remove('saved'), 2000);
                    } else {
                        inputEl.classList.add('error');
                        console.error('Failed to save payment date:', data.error);
                    }
                })
                .catch(err => {
                    inputEl.classList.remove('saving');
                    inputEl.classList.add('error');
                    console.error('Error saving payment date:', err);
                });
            });
        });
    }

    function renderRoundView(data) {
        const playersRaw = data.players || [];
        let players = [...playersRaw];
        players = applySearchFilter(players);

        const roundSelect = document.getElementById('roundSelect');
        const activeOnly = document.getElementById('activeOnly');
        // Round keys are strings like "C2-R11"
        const roundKey = roundSelect?.value || currentRoundKey || '';

        // Filter active only if toggled
        const statusVal = p => String(p.status || '').toLowerCase().trim();
        if (activeOnly?.checked) {
            players = players.filter(p => statusVal(p) === 'active');
        }

        // Sort: Active first, then by team picked in selected round (A‚ÜíZ), then by name.
        // Players without a pick for the round sort after those with picks.
        const statusPriority = s => (s === 'active' ? 0 : s === 'winner' ? 1 : 2);
        const getTeamForRound = p => {
            const pick = p.picks && p.picks[roundKey];
            return pick && pick.team ? pick.team : null;
        };
        players.sort((a, b) => {
            const sa = statusPriority(statusVal(a));
            const sb = statusPriority(statusVal(b));
            if (sa !== sb) return sa - sb;
            const ta = getTeamForRound(a);
            const tb = getTeamForRound(b);
            if (ta && tb) {
                const cmp = ta.localeCompare(tb);
                if (cmp !== 0) return cmp;
            } else if (ta && !tb) {
                return -1;
            } else if (!ta && tb) {
                return 1;
            }
            return a.name.localeCompare(b.name);
        });

        // Group by status into collapsible sections
        const groups = { active: [], winner: [], eliminated: [] };
        players.forEach(p => { const key = String(p.status||'').toLowerCase(); (groups[key] || (groups[key]=[])).push(p); });

        let html = '';
        function renderGroup(title, key, openDefault) {
            const list = groups[key] || [];
            const count = list.length;
            html += `<details ${openDefault ? 'open' : ''} class="mb-2">
                <summary class="d-flex justify-content-between align-items-center py-2 px-2 bg-light rounded">
                    <span>${title} (${count})</span>
                    <span class="status-badge status-${key}">${title.toUpperCase()}</span>
                </summary>
                <div class="table-responsive mt-2">
                    <table class="table table-sm table-hover mb-0">
                        <thead class="table-dark"><tr><th>Player</th><th>Pick</th><th>Status</th></tr></thead>
                        <tbody>
                            ${list.map(p => {
                                const pickData = (p.picks && p.picks[roundKey]) || null;
                                const pickInfo = getPickInfo(pickData, roundKey);
                                const badge = `<span class=\"status-badge status-${p.status}\">${String(p.status||'').toUpperCase()}</span>`;
                                return `<tr><td>${p.name}</td><td class=\"${pickInfo.class}\">${pickInfo.display}</td><td>${badge}</td></tr>`;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            </details>`;
        }
        renderGroup('Active', 'active', true);
        renderGroup('Winner', 'winner', false);
        renderGroup('Eliminated', 'eliminated', false);
        gridContainer.innerHTML = html;
    }

    function syncScrolling() {
        const headers = document.querySelector('.grid-headers');
        const dataGrid = document.querySelector('.grid-data');
        const names = document.querySelector('.grid-names');
        const paid = document.querySelector('.grid-paid');

        if (!headers || !dataGrid || !names) return;

        // Sync horizontal scrolling between headers and data
        dataGrid.addEventListener('scroll', function() {
            headers.scrollLeft = dataGrid.scrollLeft;
        });

        // Sync vertical scrolling between names, paid, and data
        dataGrid.addEventListener('scroll', function() {
            names.scrollTop = dataGrid.scrollTop;
            if (paid) paid.scrollTop = dataGrid.scrollTop;
        });

        // Also sync when scrolling the names column
        names.addEventListener('scroll', function() {
            dataGrid.scrollTop = names.scrollTop;
            if (paid) paid.scrollTop = names.scrollTop;
        });

        // Also sync when scrolling the paid column
        if (paid) {
            paid.addEventListener('scroll', function() {
                dataGrid.scrollTop = paid.scrollTop;
                names.scrollTop = paid.scrollTop;
            });
        }
    }

    function setupColumnResizing() {
        const resizeHandles = document.querySelectorAll('.resize-handle');
        let isResizing = false;
        let currentHandle = null;
        let startX = 0;
        let startWidth = 0;
        let columnWidths = [];

        // Initialize column widths
        const headers = document.querySelectorAll('.header-cell');
        headers.forEach((header, index) => {
            columnWidths[index] = 120; // Default width
        });

        resizeHandles.forEach(handle => {
            handle.addEventListener('mousedown', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                isResizing = true;
                currentHandle = this;
                startX = e.clientX;
                
                const colIndex = parseInt(this.getAttribute('data-col-index'));
                startWidth = columnWidths[colIndex] || 120;
                
                this.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });
        });

        document.addEventListener('mousemove', function(e) {
            if (!isResizing || !currentHandle) return;
            
            e.preventDefault();
            const deltaX = e.clientX - startX;
            const colIndex = parseInt(currentHandle.getAttribute('data-col-index'));
            const newWidth = Math.max(80, startWidth + deltaX); // Minimum 80px
            
            columnWidths[colIndex] = newWidth;
            applyColumnWidth(colIndex, newWidth);
        });

        document.addEventListener('mouseup', function(e) {
            if (isResizing) {
                isResizing = false;
                if (currentHandle) {
                    currentHandle.classList.remove('dragging');
                    currentHandle = null;
                }
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        });

        function applyColumnWidth(colIndex, width) {
            // Update header
            const header = document.querySelector(`[data-col-index="${colIndex}"]`);
            if (header) {
                header.style.width = width + 'px';
                header.style.minWidth = width + 'px';
            }

            // Update all data cells in this column
            const dataRows = document.querySelectorAll('.data-row');
            dataRows.forEach(row => {
                const cells = row.querySelectorAll('.data-cell');
                if (cells[colIndex]) {
                    cells[colIndex].style.width = width + 'px';
                    cells[colIndex].style.minWidth = width + 'px';
                }
            });

            // Update grid template columns for the headers and data rows
            updateGridColumnWidths(columnWidths);
        }

        function updateGridColumnWidths(widths) {
            const gridTemplate = widths.map(w => `${w}px`).join(' ');
            
            const headers = document.querySelector('.grid-headers');
            const dataRows = document.querySelectorAll('.data-row');
            
            if (headers) {
                headers.style.gridTemplateColumns = gridTemplate;
            }
            
            dataRows.forEach(row => {
                row.style.gridTemplateColumns = gridTemplate;
            });
        }
    }

    function getPickInfo(pickData, roundNumber) {
        if (!pickData || pickData === null) {
            return {
                display: '-',
                class: 'pick-pending',
                tooltip: 'No pick made'
            };
        }

        const team = pickData.team;
        const isWinner = pickData.is_winner;
        
        let displayClass = 'pick-pending';
        let statusText = '? Pending';
        
        if (isWinner === true) {
            displayClass = 'pick-winner';
            statusText = '‚úì Won';
        } else if (isWinner === false) {
            displayClass = 'pick-loser';
            statusText = '‚úó Lost';
        }
        
        const teamAbbrev = getTeamAbbreviation(team);
        
        return {
            display: teamAbbrev,
            class: displayClass,
            tooltip: `Round ${roundNumber}: ${team} ${statusText}`
        };
    }


    function setupEventListeners() {
        // Cycle selector
        const cycleSelect = document.getElementById('cycleSelect');
        if (cycleSelect) {
            cycleSelect.addEventListener('change', function() {
                const cycle = this.value;
                console.log('[Picks Grid] Cycle selector changed to:', cycle);
                onCycleChange(cycle);
            });
        }

        // View toggles
        document.getElementById('viewPlayer').addEventListener('click', function() {
            currentView = 'player';
            // When switching to Player View, clear single-round filter to show all rounds
            playerViewRoundFilter = null;
            updateShowAllRoundsButton();
            renderByView();
        });
        document.getElementById('viewRound').addEventListener('click', function() {
            currentView = 'round';
            renderByView();
        });

        // Mobile rounds toggle
        const toggleBtn = document.getElementById('toggleMobileRounds');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', function() {
                showAllMobileRounds = !showAllMobileRounds;
                this.textContent = showAllMobileRounds ? 'Show fewer rounds' : 'Show all rounds';
                // Keep in player view when toggling
                currentView = 'player';
                renderByView();
            });
        }

        // Sort by name
        document.getElementById('sortByName').addEventListener('click', function() {
            currentSort = 'name';
            currentView = 'player';
            renderByView();
            updateSortButtons('sortByName');
        });

        // Sort by status
        document.getElementById('sortByStatus').addEventListener('click', function() {
            currentSort = 'status';
            currentView = 'player';
            renderByView();
            updateSortButtons('sortByStatus');
        });

        // Sort by latest round
        document.getElementById('sortByLatestRound').addEventListener('click', function() {
            currentSort = 'latestRound';
            currentView = 'player';
            renderByView();
            updateSortButtons('sortByLatestRound');
        });

        // Sort by progress (Active ‚Üí Teams Picked)
        document.getElementById('sortByProgress').addEventListener('click', function() {
            currentSort = 'progress';
            currentView = 'player';
            renderByView();
            updateSortButtons('sortByProgress');
        });

        // Search
        const search = document.getElementById('playerSearch');
        if (search) {
            search.addEventListener('input', function() {
                renderByView();
            });
        }

        // Round selector - behavior differs by view
        const roundSelect = document.getElementById('roundSelect');
        if (roundSelect) {
            roundSelect.addEventListener('change', function() {
                const roundKey = this.value;
                console.log('[Picks Grid] Round selector changed to:', roundKey);

                if (currentView === 'round') {
                    // Round View: use for filtering the table
                    currentRoundKey = roundKey;
                } else {
                    // Player View: filter grid to show only this round column
                    playerViewRoundFilter = roundKey;
                    updateShowAllRoundsButton();
                }
                renderByView();
            });
        }

        // "All Rounds" button - clears single-round filter in Player View
        const showAllRoundsBtn = document.getElementById('showAllRoundsBtn');
        if (showAllRoundsBtn) {
            showAllRoundsBtn.addEventListener('click', function() {
                console.log('[Picks Grid] Showing all rounds');
                playerViewRoundFilter = null;
                updateShowAllRoundsButton();
                renderByView();
            });
        }

        const activeOnly = document.getElementById('activeOnly');
        if (activeOnly) {
            activeOnly.addEventListener('change', function() {
                renderByView();
            });
        }

        // Toggle column controls
        document.getElementById('adjustColumns').addEventListener('click', function() {
            const controls = document.getElementById('columnControls');
            controls.style.display = controls.style.display === 'none' ? 'block' : 'none';
        });

        // Export buttons - respect current cycle selection
        const exportGridBtn = document.getElementById('exportGrid');
        if (exportGridBtn) {
            exportGridBtn.addEventListener('click', function() {
                const cycleSelect = document.getElementById('cycleSelect');
                const cycle = cycleSelect ? cycleSelect.value : 'current';
                window.location.href = `/api/export/picks-grid?cycle=${cycle}`;
            });
        }
        const exportGridExcelBtn = document.getElementById('exportGridExcel');
        if (exportGridExcelBtn) {
            exportGridExcelBtn.addEventListener('click', function() {
                const cycleSelect = document.getElementById('cycleSelect');
                const cycle = cycleSelect ? cycleSelect.value : 'current';
                window.location.href = `/api/export/picks-grid-xlsx?cycle=${cycle}`;
            });
        }
    }

    function updateShowAllRoundsButton() {
        const btn = document.getElementById('showAllRoundsBtn');
        if (!btn) return;

        if (playerViewRoundFilter) {
            btn.classList.remove('btn-outline-secondary');
            btn.classList.add('btn-secondary');
        } else {
            btn.classList.remove('btn-secondary');
            btn.classList.add('btn-outline-secondary');
        }
    }

    function updateSortButtons(activeButton) {
        ['sortByName', 'sortByStatus', 'sortByLatestRound', 'sortByProgress'].forEach(id => {
            const btn = document.getElementById(id);
            if (id === activeButton) {
                btn.classList.remove('btn-outline-primary', 'btn-outline-warning', 'btn-outline-success', 'btn-outline-dark');
                if (id === 'sortByName') {
                    btn.classList.add('btn-primary');
                } else if (id === 'sortByStatus') {
                    btn.classList.add('btn-warning');
                } else if (id === 'sortByLatestRound') {
                    btn.classList.add('btn-success');
                } else if (id === 'sortByProgress') {
                    btn.classList.add('btn-dark');
                }
            } else {
                btn.classList.remove('btn-primary', 'btn-warning', 'btn-success', 'btn-dark');
                if (id === 'sortByName') {
                    btn.classList.add('btn-outline-primary');
                } else if (id === 'sortByStatus') {
                    btn.classList.add('btn-outline-warning');
                } else if (id === 'sortByLatestRound') {
                    btn.classList.add('btn-outline-success');
                } else if (id === 'sortByProgress') {
                    btn.classList.add('btn-outline-dark');
                }
            }
        });
    }
});

// Column width adjustment functions
function updateColumnWidth(type, value) {
    const displayElement = document.getElementById(`${type}WidthDisplay`);
    displayElement.textContent = value + 'px';
    
    if (type === 'name') {
        // Update name column width
        const grid = document.querySelector('.spreadsheet-grid');
        if (grid) {
            grid.style.gridTemplateColumns = `${value}px 1fr`;
        }
        document.querySelectorAll('.name-cell').forEach(cell => {
            cell.style.width = value + 'px';
        });
    } else if (type === 'round') {
        // Update round column widths
        const headers = document.querySelector('.grid-headers');
        const dataRows = document.querySelectorAll('.data-row');
        
        if (headers) {
            headers.style.gridAutoColumns = value + 'px';
        }
        
        dataRows.forEach(row => {
            row.style.gridAutoColumns = value + 'px';
        });
    }
}
</script>
{% endblock %}
