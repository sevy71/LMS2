{% extends "base.html" %}

{% block title %}Picks Grid - Last Man Standing{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12 d-flex justify-content-between align-items-center">
            <h1 class="mb-4">Picks Grid</h1>
            <a href="{{ url_for('admin_dashboard') }}" class="btn btn-outline-secondary">
                <i class="fas fa-arrow-left"></i> Back to Dashboard
            </a>
        </div>
    </div>

    <div class="card">
        <div class="card-header d-flex justify-content-between align-items-center">
            <h5 class="card-title mb-0">All Player Picks by Round</h5>
            <div class="btn-group" role="group">
                <button type="button" class="btn btn-outline-primary btn-sm" id="sortByName">
                    üìù Sort by Name
                </button>
                <button type="button" class="btn btn-outline-warning btn-sm" id="sortByStatus">
                    üéØ Group by Status
                </button>
                <button type="button" class="btn btn-outline-success btn-sm" id="sortByLatestRound">
                    üé≤ Sort by Latest Round
                </button>
                <button type="button" class="btn btn-outline-info btn-sm" id="adjustColumns">
                    üìä Adjust Columns
                </button>
            </div>
        </div>
        <div class="card-body">
            <!-- Column width control -->
            <div class="row mb-3" id="columnControls" style="display: none;">
                <div class="col-md-6">
                    <label for="nameColWidth" class="form-label">Name Column Width:</label>
                    <input type="range" class="form-range" id="nameColWidth" min="100" max="300" value="150" onchange="updateColumnWidth('name', this.value)">
                    <small class="form-text text-muted">Current: <span id="nameWidthDisplay">150px</span></small>
                </div>
                <div class="col-md-6">
                    <label for="roundColWidth" class="form-label">Round Columns Width:</label>
                    <input type="range" class="form-range" id="roundColWidth" min="80" max="200" value="120" onchange="updateColumnWidth('round', this.value)">
                    <small class="form-text text-muted">Current: <span id="roundWidthDisplay">120px</span></small>
                </div>
            </div>

            <div id="grid-container" class="spreadsheet-container">
                <p>Loading picks data...</p>
            </div>
        </div>
    </div>
</div>

<style>
/* Spreadsheet Container */
.spreadsheet-container {
    height: 70vh;
    max-height: 800px;
    border: 2px solid #dee2e6;
    border-radius: 8px;
    overflow: hidden;
    position: relative;
    background: white;
}

/* Main Grid */
.spreadsheet-grid {
    display: grid;
    height: 100%;
    overflow: hidden;
}

/* Frozen Corner (top-left) */
.grid-corner {
    position: sticky;
    top: 0;
    left: 0;
    z-index: 30;
    background: #e9ecef;
    border-right: 2px solid #adb5bd;
    border-bottom: 2px solid #adb5bd;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 0.875rem;
}

/* Frozen Headers (top row) */
.grid-headers {
    position: sticky;
    top: 0;
    z-index: 20;
    background: #e9ecef;
    border-bottom: 2px solid #adb5bd;
    display: grid;
    grid-auto-columns: 120px;
    grid-auto-flow: column;
    overflow-x: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.grid-headers::-webkit-scrollbar {
    display: none;
}

.header-cell {
    padding: 12px 8px;
    border-right: 1px solid #adb5bd;
    background: #e9ecef;
    font-weight: bold;
    text-align: center;
    font-size: 0.875rem;
    position: relative;
    user-select: none;
}

.header-cell:hover {
    background: #d6d9dc;
}

.header-cell::after {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 4px;
    height: 100%;
    cursor: col-resize;
    background: transparent;
}

.header-cell:hover::after {
    background: rgba(0, 123, 255, 0.3);
}

.resize-handle {
    position: absolute;
    top: 0;
    right: -2px;
    width: 4px;
    height: 100%;
    cursor: col-resize;
    background: transparent;
    z-index: 10;
}

.resize-handle:hover,
.resize-handle.dragging {
    background: rgba(0, 123, 255, 0.5);
}

/* Frozen Name Column */
.grid-names {
    position: sticky;
    left: 0;
    z-index: 10;
    background: white;
    border-right: 2px solid #adb5bd;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.grid-names::-webkit-scrollbar {
    display: none;
}

.name-cell {
    padding: 10px 12px;
    border-bottom: 1px solid #dee2e6;
    background: white;
    font-weight: 600;
    font-size: 0.875rem;
    height: 45px;
    min-height: 45px;
    max-height: 45px;
    display: flex;
    align-items: center;
    position: relative;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* Data Grid */
.grid-data {
    overflow: auto;
    background: white;
}

.data-row {
    display: grid;
    grid-auto-columns: 120px;
    grid-auto-flow: column;
    border-bottom: 1px solid #dee2e6;
    height: 45px;
    min-height: 45px;
    max-height: 45px;
}

.data-cell {
    padding: 8px 6px;
    border-right: 1px solid #dee2e6;
    text-align: center;
    font-size: 0.875rem;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    background: white;
    height: 45px;
    min-height: 45px;
    max-height: 45px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* Alternating row colors */
.data-row:nth-child(even) .data-cell {
    background-color: #f8f9fa;
}

.name-cell:nth-child(even) {
    background-color: #f8f9fa;
}

/* Pick status styles */
.pick-winner {
    background-color: #d4edda !important;
    color: #155724;
    font-weight: bold;
}

.pick-loser {
    background-color: #f8d7da !important;
    color: #721c24;
    text-decoration: line-through;
}

.pick-pending {
    background-color: #fff3cd !important;
    color: #856404;
}

/* Player status row indicators */
.name-cell.player-eliminated {
    border-left: 4px solid #dc3545;
}

.name-cell.player-active {
    border-left: 4px solid #28a745;
}

.name-cell.player-winner {
    border-left: 4px solid #007bff;
}

/* Status badges */
.status-badge {
    font-size: 0.7rem;
    padding: 3px 8px;
    border-radius: 12px;
    font-weight: bold;
}

.status-active {
    background-color: #28a745;
    color: white;
}

.status-eliminated {
    background-color: #dc3545;
    color: white;
}

.status-winner {
    background-color: #007bff;
    color: white;
}

/* Group headers for status sorting */
.group-header {
    grid-column: 1 / -1;
    padding: 8px 16px;
    background: #6c757d;
    color: white;
    font-weight: bold;
    text-align: center;
    font-size: 0.875rem;
}

/* Scrollbar styling */
.grid-data::-webkit-scrollbar {
    width: 12px;
    height: 12px;
}

.grid-data::-webkit-scrollbar-track {
    background: #f1f1f1;
}

.grid-data::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 6px;
}

.grid-data::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .spreadsheet-container {
        height: 60vh;
    }
    
    .grid-corner {
        width: 120px;
    }
    
    .header-cell,
    .data-cell {
        min-width: 100px;
    }
}
</style>
{% endblock %}

{% block scripts %}
<script>
// Premier League team abbreviations mapping
function getTeamAbbreviation(teamName) {
    const abbreviations = {
        'Arsenal': 'ARS',
        'Aston Villa': 'AVFC',
        'Aston Villa FC': 'AVFC',
        'AFC Bournemouth': 'BOU',
        'Bournemouth': 'BOU',
        'Bournemouth AFC': 'BOU',
        'Brentford': 'BRE',
        'Brighton': 'BHA',
        'Brighton & Hove Albion': 'BHA',
        'Burnley': 'BUR',
        'Chelsea': 'CHE',
        'Crystal Palace': 'CRY',
        'Everton': 'EVE',
        'Everton FC': 'EVE',
        'Fulham': 'FUL',
        'Liverpool': 'LIV',
        'Liverpool FC': 'LIV',
        'Luton Town': 'LUT',
        'Manchester City': 'MCI',
        'Manchester City FC': 'MCI',
        'Manchester United': 'MUN',
        'Manchester United FC': 'MUN',
        'Newcastle': 'NEW',
        'Newcastle United': 'NEW',
        'Nottingham Forest': 'NOT',
        'Sheffield United': 'SHE',
        'Tottenham': 'TOT',
        'Tottenham Hotspur': 'TOT',
        'Tottenham Hotspur FC': 'TOT',
        'West Ham': 'WHU',
        'West Ham United': 'WHU',
        'Wolves': 'WOL',
        'Wolverhampton Wanderers': 'WOL'
    };
    
    return abbreviations[teamName] || teamName.substring(0, 3).toUpperCase();
}

let gridData = null;
let currentSort = 'name';

document.addEventListener('DOMContentLoaded', function() {
    const gridContainer = document.getElementById('grid-container');

    // Load data
    fetch('/api/picks-grid-data')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                gridData = data;
                renderGrid(data);
                setupEventListeners();
            } else {
                gridContainer.innerHTML = `<div class="alert alert-danger">Error loading data: ${data.error}</div>`;
            }
        })
        .catch(error => {
            console.error('Error fetching picks grid data:', error);
            gridContainer.innerHTML = '<div class="alert alert-danger">Could not fetch data from the server.</div>';
        });

    function renderGrid(data, sortBy = 'name') {
        const rounds = data.rounds;
        let players = [...data.players]; // Create a copy

        if (players.length === 0) {
            gridContainer.innerHTML = '<p class="text-muted">No players found.</p>';
            return;
        }

        // Sort players
        if (sortBy === 'name') {
            players.sort((a, b) => a.name.localeCompare(b.name));
        } else if (sortBy === 'status') {
            // Group by status: active first, then eliminated, then winner
            players.sort((a, b) => {
                const statusOrder = { 'active': 1, 'eliminated': 2, 'winner': 3 };
                const aOrder = statusOrder[a.status] || 4;
                const bOrder = statusOrder[b.status] || 4;
                if (aOrder !== bOrder) return aOrder - bOrder;
                return a.name.localeCompare(b.name); // Secondary sort by name
            });
        } else if (sortBy === 'latestRound') {
            // Sort by latest round pick in ascending order
            const latestRound = Math.max(...rounds);
            players.sort((a, b) => {
                const aLatestPick = a.picks[latestRound];
                const bLatestPick = b.picks[latestRound];
                
                // Players without picks go to the end
                if (!aLatestPick && !bLatestPick) return a.name.localeCompare(b.name);
                if (!aLatestPick) return 1;
                if (!bLatestPick) return -1;
                
                // Sort by team name in ascending order
                const teamCompare = aLatestPick.team.localeCompare(bLatestPick.team);
                if (teamCompare !== 0) return teamCompare;
                
                // Secondary sort by name if same team
                return a.name.localeCompare(b.name);
            });
        }

        // Create spreadsheet grid structure
        let gridHtml = '<div class="spreadsheet-grid" style="grid-template-columns: 180px 1fr;">';
        
        // Top-left corner
        gridHtml += '<div class="grid-corner">Player</div>';
        
        // Headers
        gridHtml += '<div class="grid-headers">';
        rounds.forEach((roundNumber, index) => {
            gridHtml += `<div class="header-cell" data-round="${roundNumber}" data-col-index="${index}">
                R${roundNumber}
                <div class="resize-handle" data-col-index="${index}"></div>
            </div>`;
        });
        gridHtml += `<div class="header-cell" data-col-index="${rounds.length}">
            Status
            <div class="resize-handle" data-col-index="${rounds.length}"></div>
        </div>`;
        gridHtml += '</div>';
        
        // Name column
        gridHtml += '<div class="grid-names">';
        let currentGroup = '';
        players.forEach((player, index) => {
            // Add group separator for status sorting
            if (sortBy === 'status' && currentGroup !== player.status) {
                currentGroup = player.status;
                const groupName = player.status.charAt(0).toUpperCase() + player.status.slice(1);
                const badgeClass = `status-${player.status}`;
                gridHtml += `<div class="name-cell group-header">
                    <span class="status-badge ${badgeClass}">${groupName} Players</span>
                </div>`;
            }
            
            const statusClass = `player-${player.status}`;
            gridHtml += `<div class="name-cell ${statusClass}">${player.name}</div>`;
        });
        gridHtml += '</div>';
        
        // Data grid
        gridHtml += '<div class="grid-data" id="dataGrid">';
        currentGroup = '';
        players.forEach((player, index) => {
            // Add group separator for status sorting
            if (sortBy === 'status' && currentGroup !== player.status) {
                currentGroup = player.status;
                gridHtml += '<div class="data-row"><div class="group-header"></div></div>';
            }
            
            gridHtml += '<div class="data-row">';
            
            // Round columns
            rounds.forEach(roundNumber => {
                const pickData = player.picks[roundNumber];
                const pickInfo = getPickInfo(pickData, roundNumber);
                gridHtml += `<div class="data-cell ${pickInfo.class}" title="${pickInfo.tooltip}">${pickInfo.display}</div>`;
            });

            // Status column
            const statusBadge = `<span class="status-badge status-${player.status}">${player.status.toUpperCase()}</span>`;
            gridHtml += `<div class="data-cell">${statusBadge}</div>`;

            gridHtml += '</div>';
        });
        gridHtml += '</div>';
        
        gridHtml += '</div>';
        gridContainer.innerHTML = gridHtml;
        
        // Sync scrolling between headers and data
        syncScrolling();
        
        // Setup column resizing
        setupColumnResizing();
    }

    function syncScrolling() {
        const headers = document.querySelector('.grid-headers');
        const dataGrid = document.querySelector('.grid-data');
        const names = document.querySelector('.grid-names');
        
        if (!headers || !dataGrid || !names) return;
        
        // Sync horizontal scrolling between headers and data
        dataGrid.addEventListener('scroll', function() {
            headers.scrollLeft = dataGrid.scrollLeft;
        });
        
        // Sync vertical scrolling between names and data
        dataGrid.addEventListener('scroll', function() {
            names.scrollTop = dataGrid.scrollTop;
        });
        
        // Also sync when scrolling the names column
        names.addEventListener('scroll', function() {
            dataGrid.scrollTop = names.scrollTop;
        });
    }

    function setupColumnResizing() {
        const resizeHandles = document.querySelectorAll('.resize-handle');
        let isResizing = false;
        let currentHandle = null;
        let startX = 0;
        let startWidth = 0;
        let columnWidths = [];

        // Initialize column widths
        const headers = document.querySelectorAll('.header-cell');
        headers.forEach((header, index) => {
            columnWidths[index] = 120; // Default width
        });

        resizeHandles.forEach(handle => {
            handle.addEventListener('mousedown', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                isResizing = true;
                currentHandle = this;
                startX = e.clientX;
                
                const colIndex = parseInt(this.getAttribute('data-col-index'));
                startWidth = columnWidths[colIndex] || 120;
                
                this.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });
        });

        document.addEventListener('mousemove', function(e) {
            if (!isResizing || !currentHandle) return;
            
            e.preventDefault();
            const deltaX = e.clientX - startX;
            const colIndex = parseInt(currentHandle.getAttribute('data-col-index'));
            const newWidth = Math.max(80, startWidth + deltaX); // Minimum 80px
            
            columnWidths[colIndex] = newWidth;
            applyColumnWidth(colIndex, newWidth);
        });

        document.addEventListener('mouseup', function(e) {
            if (isResizing) {
                isResizing = false;
                if (currentHandle) {
                    currentHandle.classList.remove('dragging');
                    currentHandle = null;
                }
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        });

        function applyColumnWidth(colIndex, width) {
            // Update header
            const header = document.querySelector(`[data-col-index="${colIndex}"]`);
            if (header) {
                header.style.width = width + 'px';
                header.style.minWidth = width + 'px';
            }

            // Update all data cells in this column
            const dataRows = document.querySelectorAll('.data-row');
            dataRows.forEach(row => {
                const cells = row.querySelectorAll('.data-cell');
                if (cells[colIndex]) {
                    cells[colIndex].style.width = width + 'px';
                    cells[colIndex].style.minWidth = width + 'px';
                }
            });

            // Update grid template columns for the headers and data rows
            updateGridColumnWidths(columnWidths);
        }

        function updateGridColumnWidths(widths) {
            const gridTemplate = widths.map(w => `${w}px`).join(' ');
            
            const headers = document.querySelector('.grid-headers');
            const dataRows = document.querySelectorAll('.data-row');
            
            if (headers) {
                headers.style.gridTemplateColumns = gridTemplate;
            }
            
            dataRows.forEach(row => {
                row.style.gridTemplateColumns = gridTemplate;
            });
        }
    }

    function getPickInfo(pickData, roundNumber) {
        if (!pickData || pickData === null) {
            return {
                display: '-',
                class: 'pick-pending',
                tooltip: 'No pick made'
            };
        }

        const team = pickData.team;
        const isWinner = pickData.is_winner;
        
        let displayClass = 'pick-pending';
        let statusText = '? Pending';
        
        if (isWinner === true) {
            displayClass = 'pick-winner';
            statusText = '‚úì Won';
        } else if (isWinner === false) {
            displayClass = 'pick-loser';
            statusText = '‚úó Lost';
        }
        
        const teamAbbrev = getTeamAbbreviation(team);
        
        return {
            display: teamAbbrev,
            class: displayClass,
            tooltip: `Round ${roundNumber}: ${team} ${statusText}`
        };
    }


    function setupEventListeners() {
        // Sort by name
        document.getElementById('sortByName').addEventListener('click', function() {
            currentSort = 'name';
            renderGrid(gridData, 'name');
            updateSortButtons('sortByName');
        });

        // Sort by status
        document.getElementById('sortByStatus').addEventListener('click', function() {
            currentSort = 'status';
            renderGrid(gridData, 'status');
            updateSortButtons('sortByStatus');
        });

        // Sort by latest round
        document.getElementById('sortByLatestRound').addEventListener('click', function() {
            currentSort = 'latestRound';
            renderGrid(gridData, 'latestRound');
            updateSortButtons('sortByLatestRound');
        });

        // Toggle column controls
        document.getElementById('adjustColumns').addEventListener('click', function() {
            const controls = document.getElementById('columnControls');
            controls.style.display = controls.style.display === 'none' ? 'block' : 'none';
        });
    }

    function updateSortButtons(activeButton) {
        ['sortByName', 'sortByStatus', 'sortByLatestRound'].forEach(id => {
            const btn = document.getElementById(id);
            if (id === activeButton) {
                btn.classList.remove('btn-outline-primary', 'btn-outline-warning', 'btn-outline-success');
                if (id === 'sortByName') {
                    btn.classList.add('btn-primary');
                } else if (id === 'sortByStatus') {
                    btn.classList.add('btn-warning');
                } else if (id === 'sortByLatestRound') {
                    btn.classList.add('btn-success');
                }
            } else {
                btn.classList.remove('btn-primary', 'btn-warning', 'btn-success');
                if (id === 'sortByName') {
                    btn.classList.add('btn-outline-primary');
                } else if (id === 'sortByStatus') {
                    btn.classList.add('btn-outline-warning');
                } else if (id === 'sortByLatestRound') {
                    btn.classList.add('btn-outline-success');
                }
            }
        });
    }
});

// Column width adjustment functions
function updateColumnWidth(type, value) {
    const displayElement = document.getElementById(`${type}WidthDisplay`);
    displayElement.textContent = value + 'px';
    
    if (type === 'name') {
        // Update name column width
        const grid = document.querySelector('.spreadsheet-grid');
        if (grid) {
            grid.style.gridTemplateColumns = `${value}px 1fr`;
        }
        document.querySelectorAll('.name-cell').forEach(cell => {
            cell.style.width = value + 'px';
        });
    } else if (type === 'round') {
        // Update round column widths
        const headers = document.querySelector('.grid-headers');
        const dataRows = document.querySelectorAll('.data-row');
        
        if (headers) {
            headers.style.gridAutoColumns = value + 'px';
        }
        
        dataRows.forEach(row => {
            row.style.gridAutoColumns = value + 'px';
        });
    }
}
</script>
{% endblock %}
